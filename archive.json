{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-07-28T00:21:57.157335+00:00",
  "repo": "huitema/quic-in-space",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 3,
      "id": "I_kwDOKFdyE85vrjX2",
      "title": "idle_timeout = zero",
      "url": "https://github.com/huitema/quic-in-space/issues/3",
      "state": "OPEN",
      "author": "marcblanchet",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We are currently talking about the idle_timeout which would have a value, but I think we should say something about not setting the idle_timeout. In fact, that should be a strong recommendation. Because the use case of deep space is that the ground stations and systems will be \"talking\" to the spacecrafts for as long as the whole lifetime of the mission: e.g. months, years, sometimes decades. And given that re-establishing a connection is \"costly\" in space because of delays and disruptions, and that re-establishing a connection is actually an additional risk if it fails or take too much time (think of urgent command to be sent because of a big issue), then the idle_timeout shall be preferred to be not set or set to zero.  I can write something and make a PR if you agree.",
      "createdAt": "2023-08-30T13:30:25Z",
      "updatedAt": "2023-08-30T18:10:30Z",
      "closedAt": null,
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "OWNER",
          "body": "There are two parts: adapting to long delay links so the timeout does not cause unwanted disconnection; and, not closing connections unless explicitly asked for by the application. The first point is solved by the original QUIC spec mandating that the timeout is the max of the stated value and 3 times the RTT. The second point is entirely up to the application.\r\n\r\nSuppose a 20 minutes RTT. The default would be to close the connection after an hour of silence (3*RTT). The alternative, zero timeout, would be to allow transmission on the connection to continue after an hour of silence. The expectation is that just continuing would be less costly than restarting a new connection. I am not sure these expectations are true:\r\n\r\n1) After a long period of silence, we have an ambiguous situation. Is the other end still there, or not? If it is there, sending more data is mostly fine. If it is not, sending more data will cause packet losses, which will cause the closure of the connection after several retransmission attempts. It is not clear that this is better than a new connection attempt.\r\n\r\n2) After a long period of silence, the transmission conditions may have changed. Stations or relays may have moved, the transmission balance of some paths may have been altered, etc. The connection will have to find out the new values, and that process is very similar to starting a new connection.\r\n\r\n3) QUIC supports resuming and 0-RTT. If we also remember the RTT and BDP from previous connections, starting a new connection is going to be very efficient.\r\n\r\nEven if we want to maintain long duration connections, I think the solution is to mandate a \"keep alive\" process, such as a ping every 20 minutes, to make sure that the timeout does not expire. This is much more likely to work than just ignoring long silences and hoping that the link is still there.",
          "createdAt": "2023-08-30T17:18:01Z",
          "updatedAt": "2023-08-30T17:18:01Z"
        },
        {
          "author": "marcblanchet",
          "authorAssociation": "COLLABORATOR",
          "body": "all good points. I wonder if these should be somewhat put in the draft. To me, there are really relevant, maybe more on the deployment side than pure implementation, but it could also show the choices for the base implementation to choose (aka externalize idle_timeout, making it per connection, per destination, ...",
          "createdAt": "2023-08-30T18:10:30Z",
          "updatedAt": "2023-08-30T18:10:30Z"
        }
      ]
    },
    {
      "number": 4,
      "id": "I_kwDOKFdyE85vrlN2",
      "title": "about draft-ietf-tsvwg-careful-resume",
      "url": "https://github.com/huitema/quic-in-space/issues/4",
      "state": "OPEN",
      "author": "marcblanchet",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Should we talk about draft-ietf-tsvwg-careful-resume? that could be useful? ",
      "createdAt": "2023-08-30T13:34:32Z",
      "updatedAt": "2023-08-30T17:19:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "OWNER",
          "body": "Yes. That should come in the recommendation parts. The draft should cite all these efforts.",
          "createdAt": "2023-08-30T17:19:15Z",
          "updatedAt": "2023-08-30T17:19:15Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "I_kwDOKFdyE85vrozD",
      "title": "on initial connection on Earth",
      "url": "https://github.com/huitema/quic-in-space/issues/5",
      "state": "OPEN",
      "author": "marcblanchet",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "An idea, mostly for deployment setup, but could be worth discussing, if the idea \"flies\".   Given that a spacecraft is something setup years in advance, well controlled, ..., what about configuring and setting up the initial QUIC connection while the ground systems and the spacecraft are still on Earth. Therefore, the security association is done, connection is established. Then, maybe using careful-resume, update the RTT as the spacecraft moves in space. This decreases the risk of issue with connection establishment while in space, avoiding the possible packet losses complication at connection establishment time.",
      "createdAt": "2023-08-30T13:41:51Z",
      "updatedAt": "2023-08-30T18:11:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "OWNER",
          "body": "Sure, but what if the connection breaks for some reason? Don't we have to then start new connections?\r\n\r\nMaybe we should instead program the list of \"trusted certificates\" in the spacecraft before launch, and look at issues such as key expiration.\r\n\r\nLike, what would that do for Voyager?",
          "createdAt": "2023-08-30T17:22:09Z",
          "updatedAt": "2023-08-30T17:22:09Z"
        },
        {
          "author": "marcblanchet",
          "authorAssociation": "COLLABORATOR",
          "body": "trusted certificates would be a must. and key expiration is required to be handled. Again, probably more deployment considerations, but might be worth mentioning. ",
          "createdAt": "2023-08-30T18:11:59Z",
          "updatedAt": "2023-08-30T18:11:59Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOKFdyE85yf0Ov",
      "title": "32 bits vars",
      "url": "https://github.com/huitema/quic-in-space/issues/8",
      "state": "OPEN",
      "author": "marcblanchet",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As you found in picoquic, time related vars that encode microseconds will be short if encoded as 32 bit integer, which means around 30 minutes max. There should be some text about that.",
      "createdAt": "2023-10-01T19:56:48Z",
      "updatedAt": "2023-10-02T06:21:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "marcblanchet",
          "authorAssociation": "COLLABORATOR",
          "body": "I can start one if you'd like",
          "createdAt": "2023-10-01T19:57:46Z",
          "updatedAt": "2023-10-01T19:57:46Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "OWNER",
          "body": "~They are 64 bits by default. Where do se use 32 bits?~\r\n\r\nSorry, I misread the question. Yes, that's a potential issue. Note that the RFC does not ask anyone to store the time variables as microseconds. The ACK frame has an \"ACK Delay\" variable nominally in microseconds, but each endpoint can use an \"ack_delay_exponent\" of up to 20, and the microsecond value is \"ack_delay<<exponent\" -- use exponent 10 for milliseconds, give or take. RFC9002 introduces a value \"kGranularity\", effectively the unit of time for computation of RTT, etc., and the recommended value is 1ms.\r\n\r\nUsing ms, 32 bits would last about 49 days. Not great, but not 30 minutes...",
          "createdAt": "2023-10-01T21:25:44Z",
          "updatedAt": "2023-10-02T06:21:38Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "I_kwDOKFdyE850lZO8",
      "title": "congestion control algorithm",
      "url": "https://github.com/huitema/quic-in-space/issues/9",
      "state": "OPEN",
      "author": "marcblanchet",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "need a section on congestion control algorithm: cubic vs newreno vs bbr vs bbrv2",
      "createdAt": "2023-10-22T16:12:23Z",
      "updatedAt": "2023-11-06T07:25:18Z",
      "closedAt": null,
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "OWNER",
          "body": "Yes. There are a few well known issues, and also a few subtle ones.\r\n\r\nReno embed time constants that makes it very inefficient on links with a large Bandwidth*Delay product.  In congestion avoidance mode, Reno increases the bandwidth by one packet per RTT -- and then shrinks the window by half in case of packet loss. This is a well known issue, discussed for example by Sally Floyd in [RFC3649](https://www.ietf.org/rfc/rfc3649.txt). Bottom line, Reno cannot be used on deep space links.\r\n\r\nCubic is in theory a bit better, but there is a catch. Cubic grows the window as a function of time spent from the beginning of the epoch, with the formula: \r\n\r\nWcubic(t) = C \\* (t - K)\\*\\*3 + Wmax\r\n\r\nIn that formula, C is a scaling constant determining the aggressiveness of the protocol in packets per second**3, and t is the time in seconds since the beginning of the epoch -- the recommended value being 0.4. The variable K in this formula acts as some kind of pseudo period. The window grows from an initial value at the beginning of the epoch to the nominal value \"Wmax\" after K seconds, after what it increases to probe the capacity of the link.\r\n\r\nK is computed at the beginning of the epoch as:\r\n\r\nK = cubic_root((Wmax - cwnd(epoch))/C)\r\n\r\nIn stable operation, Wmax is the congestion window at the end of the previous epoch, and \"cwnd(epoch)\" is the desired congestion window at the beginning of the epoch. Normally, cwnd(epoch) is set to beta\\*Wmax, the recommended value of beta being 0.7. We can assume that Wmax is the bandwidth\\*delay product, in packets, to get the formulas:\r\n\r\nWmax = BDP\r\ncwnd = beta\\*BDP\r\nK = cubic_root(BDP\\*(1-beta)/C)\r\n\r\nNow, let's plot the values for a variety of delays:\r\n\r\nC | Beta | Packet size (bytes) | RTT(sec) | Data rate (Mbps) | BDP (packets) | K (sec)\r\n--|------|---------------------|----------|------------------|---------------|--------\r\n0.4 | 0.7 | 1500 | 0.1 | 1 | 8 | 2\r\n0.4 | 0.7 | 1500 | 0.1 | 10 | 83 | 4\r\n0.4 | 0.7 | 1500 | 0.1 | 100 | 833 | 9\r\n0.4 | 0.7 | 1500 | 2 | 1 | 167 | 5\r\n0.4 | 0.7 | 1500 | 2 | 10 | 1667 | 11\r\n0.4 | 0.7 | 1500 | 2 | 100 | 16667 | 23\r\n0.4 | 0.7 | 1500 | 600 | 1 | 50000 | 33\r\n0.4 | 0.7 | 1500 | 600 | 10 | 500000 | 72\r\n0.4 | 0.7 | 1500 | 600 | 100 | 5000000 | 155\r\n0.4 | 0.7 | 1500 | 1200 | 0.1 | 100000 | 20\r\n0.4 | 0.7 | 1500 | 1200 | 1 | 1000000 | 42\r\n0.4 | 0.7 | 1500 | 1200 | 10 | 10000000 | 91\r\n0.4 | 0.7 | 1500 | 1200 | 100 | 100000000 | 196\r\n\r\nWhat we can see is that the value of K gets larger than the RTT as soon as the RTT is above several minutes. This is a very different behavior from the \"terrestrial\" or even \"GEO\" conditions, in which each \"saw tooth\" lasts many RTT. Basically, that means Cubic, too, is not going to work. Yes, it is possible to pick different values of C that restore some sanity, but that means creating a loop between RTT measurement and Cubic parameters, something that Cubic designers expressly did not want. They wanted the grow curve to be independent of RTT, so connections with different RTT would still be treated fairly.\r\n\r\nBBR does perform much better, because it does not have constants with time dimension. It simply adapts to the RTT. It will work, as long as the RTT does not increase too much during the connection.\r\n",
          "createdAt": "2023-11-06T07:10:30Z",
          "updatedAt": "2023-11-06T07:25:18Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "I_kwDOKFdyE850lZ2u",
      "title": "api and applications",
      "url": "https://github.com/huitema/quic-in-space/issues/10",
      "state": "OPEN",
      "author": "marcblanchet",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "currently the draft kinda take the quic stack developer point of view. Appropriate and useful guidelines for the user of a QUIC stack API for the config of a new connection. (we could reference TAPS as an example, but not limited to). \r\n\r\nI can think of:\r\n- set keep alive to none or set the value to the largest expected RTT.  (TAPS has it)\r\n- set idle_timeout (TAPS has it)\r\n- set congestion control algorithm \r\n- set initial rtt\r\n",
      "createdAt": "2023-10-22T16:19:44Z",
      "updatedAt": "2023-10-22T16:19:44Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 11,
      "id": "I_kwDOKFdyE850sbZd",
      "title": "ack frequency",
      "url": "https://github.com/huitema/quic-in-space/issues/11",
      "state": "OPEN",
      "author": "marcblanchet",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "draft-ietf-quic-ack-frequency seems pretty relevant to what we are doing. Might want to say something about it",
      "createdAt": "2023-10-23T18:47:18Z",
      "updatedAt": "2023-11-06T17:24:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "OWNER",
          "body": "Already implemented and used in the trials. Does considerably reduce the ACK overhead in our case.",
          "createdAt": "2023-11-06T07:51:37Z",
          "updatedAt": "2023-11-06T07:51:37Z"
        },
        {
          "author": "marcblanchet",
          "authorAssociation": "COLLABORATOR",
          "body": "should say a word on this in the draft: should highly consider implementing ack-frequency and also provide some hints on how to properly set the values.",
          "createdAt": "2023-11-06T13:56:24Z",
          "updatedAt": "2023-11-06T13:56:24Z"
        },
        {
          "author": "huitema",
          "authorAssociation": "OWNER",
          "body": "We could, but the parameters are mostly the same as for terrestrial network -- the time between ACK is set as a fraction of the RTT, the number of packets set as fraction of the CWIN, so it adapts automatically.\r\n",
          "createdAt": "2023-11-06T17:24:50Z",
          "updatedAt": "2023-11-06T17:24:50Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "I_kwDOKFdyE8517YOM",
      "title": "Long duration connections with intermittent connectivity",
      "url": "https://github.com/huitema/quic-in-space/issues/12",
      "state": "OPEN",
      "author": "huitema",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "We need a discussion there, because it is not obvious that long duration connections work well, especially with intermittent connectivity, like what would occur between Earth and a station on a rotating planet.\r\n\r\nSuppose that the normal RTT is 20 minutes, but that every 12 hours the connectivity is suspended for 12 hours. The endpoints will detect the failure of the connectivity after 1 PTO, which is about 1 RTT. The QUIC code will attempt to repeat the last packet, per RFC 9002, and wait first for one RTO, then double that after each iteration. This gives the following:\r\n\r\nRTT | Iteration | Timeout (s) | Time elapsed (hours)\r\n----| ----------| ------------| --------------------\r\n12000 | 0 | 1200 | 0.33\r\n12000 | 1 | 1200 | 0.67\r\n12000 | 2 | 2400 | 1.33\r\n12000 | 3 | 4800 | 2.67\r\n12000 | 4 | 9600 | 5.33\r\n12000 | 5 | 19200 | 10.67\r\n12000 | 6 | 38400 | 21.33\r\n12000 | 7 | 76800| *21.67*\r\n\r\n\r\nWe can certainly let the endpoints do that, but look what happens at the end. At the repetition number 6, the exponential backoff has increased the timeout to over 10 hours. The repetition number 7 starts 21:20 hours after the initial \"cut\", when the timeout number 6 fires. It succeeds, ant the endpoint learns at 21:40 that the link is back on. But that's 9:40 hours after the path was restored!\r\n\r\nIn short, relying on the standard timer behavior is not good enough. We will need a new parameter, something like a maximum interval between repetitions, set as a fraction of the average duration of connectivity. Or, we will have to add a \"connectivity restored\" signal of some kind, to kick the QUIC stack out of its sleeping state.",
      "createdAt": "2023-11-06T07:44:51Z",
      "updatedAt": "2023-11-06T07:50:22Z",
      "closedAt": null,
      "comments": [
        {
          "author": "huitema",
          "authorAssociation": "OWNER",
          "body": "There are other issues. We want connections to last \"forever\", and keep repeating some kind of probe until they get a reply. But what if a connection is actually broken? Some of the end to end connections go to the work stations of the controller. What if that work station fails, or is rebooted for a system update?\r\n\r\nMost QUIC deployment avoid connections that last too long, and instead rely on QUIC \"session resumption\" facility (with or without 0 RTT). \r\n\r\nIt might be good to consider that all these 'periodic ping' and other 'session resume attempts' should be started by the system with the most resource, e.g., a workstation rather than a spacecraft.",
          "createdAt": "2023-11-06T07:50:22Z",
          "updatedAt": "2023-11-06T07:50:22Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOKFdyE85Xq9E4",
      "title": "Add considerations for packet losses",
      "url": "https://github.com/huitema/quic-in-space/pull/1",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-08-10T19:34:11Z",
      "updatedAt": "2023-08-10T19:36:44Z",
      "baseRepository": "huitema/quic-in-space",
      "baseRefName": "main",
      "baseRefOid": "1b3a6d767916f5f1626fb4616412585b9cc4dad5",
      "headRepository": "huitema/quic-in-space",
      "headRefName": "packet-losses",
      "headRefOid": "071a739d1c110e5146f8963b930ab442f22f0988",
      "closedAt": "2023-08-10T19:36:44Z",
      "mergedAt": "2023-08-10T19:36:44Z",
      "mergedBy": "huitema",
      "mergeCommit": {
        "oid": "17a273b114e12274cd8c8a984d3d1e9089e8b12e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOKFdyE85ZFw-J",
      "title": "Text on flow control, congestion control and packet losses.",
      "url": "https://github.com/huitema/quic-in-space/pull/2",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-08-30T01:21:20Z",
      "updatedAt": "2023-08-30T01:25:27Z",
      "baseRepository": "huitema/quic-in-space",
      "baseRefName": "main",
      "baseRefOid": "17a273b114e12274cd8c8a984d3d1e9089e8b12e",
      "headRepository": "huitema/quic-in-space",
      "headRefName": "packet-losses",
      "headRefOid": "875eb22a43fcc26358d93e048a02da8477fa1052",
      "closedAt": "2023-08-30T01:25:14Z",
      "mergedAt": "2023-08-30T01:25:14Z",
      "mergedBy": "huitema",
      "mergeCommit": {
        "oid": "9f6b05897c94053f60b4083940d1ed8de5277420"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 6,
      "id": "PR_kwDOKFdyE85ZJIcL",
      "title": "no substantial changes, just wording, typos, english",
      "url": "https://github.com/huitema/quic-in-space/pull/6",
      "state": "OPEN",
      "author": "marcblanchet",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-08-30T13:45:41Z",
      "updatedAt": "2023-08-30T17:23:52Z",
      "baseRepository": "huitema/quic-in-space",
      "baseRefName": "main",
      "baseRefOid": "9f6b05897c94053f60b4083940d1ed8de5277420",
      "headRepository": "marcblanchet/quic-in-space-fork",
      "headRefName": "main",
      "headRefOid": "43d73bb89001dd7ab4726d6eef147753c92281f2",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOKFdyE85fjo5W",
          "commit": {
            "abbreviatedOid": "43d73bb"
          },
          "author": "huitema",
          "authorAssociation": "OWNER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-08-30T17:23:52Z",
          "updatedAt": "2023-08-30T17:23:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 7,
      "id": "PR_kwDOKFdyE85bEMkV",
      "title": "Finish the version 00 of the draft.",
      "url": "https://github.com/huitema/quic-in-space/pull/7",
      "state": "MERGED",
      "author": "huitema",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-09-24T21:38:05Z",
      "updatedAt": "2023-09-24T23:06:20Z",
      "baseRepository": "huitema/quic-in-space",
      "baseRefName": "main",
      "baseRefOid": "9f6b05897c94053f60b4083940d1ed8de5277420",
      "headRepository": "huitema/quic-in-space",
      "headRefName": "finish-00",
      "headRefOid": "4c3341b1452b6b5bc04ac642d48bfbae6dfbbb06",
      "closedAt": "2023-09-24T23:06:03Z",
      "mergedAt": "2023-09-24T23:06:02Z",
      "mergedBy": "huitema",
      "mergeCommit": {
        "oid": "53a57fbad64c0d036a11727a67ef488c83c375a8"
      },
      "comments": [],
      "reviews": []
    }
  ]
}